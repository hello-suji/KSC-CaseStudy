# 복합 목표 기반 LLM 자동 테스트 생성 실험 보고서

## 1. 실험 소개

### 1.1 실험 목적

본 실험은 대형 언어 모델을 활용한 자동 테스트 생성 과정에서, 분기 흐름·정의–사용 체인·예외 경로를 통합한 복합 테스트 목표가 커버리지 향상에 미치는 영향을 검증하는 것을 목적으로 한다. 단순 코드 입력 기반 생성 방식의 한계를 보완하기 위해 구조적 실행 목표를 명시적으로 제시하여, LLM이 더 깊은 경로를 탐색하도록 유도하였다.

### 1.2 실험 개요

실험 절차는 다음과 같다.

1. 기준선 커버리지 측정(pytest)
2. 미커버 라인/분기 관측 결과 기반 초기 분석
3. 복합 목표 생성(Gain-On-Cost 기반 Top-K 선택)
4. LLM 초기 테스트 생성(JSON 출력 기반)
5. 실패/미도달 테스트에 대해 refine 프롬프트 적용
6. 최종 테스트 스위트 실행 및 커버리지 비교

---

## 2. 사용된 프롬프트 예시

### 2.1 초기 생성 프롬프트 예시 (3.4 단계)

```
SYSTEM:
당신은 주어진 실행 목표를 타격하는 pytest 테스트를 생성하는 엔진입니다.
출력은 아래 JSON 형식만 허용합니다:
{
  "filename": "test_*.py",
  "tests": [
    {"name": "test_*", "code": "<pytest code>"} 
  ]
}

규칙:
- importlib.import_module + getattr만 사용
- 외부 의존성(파일, 네트워크, 시간, 환경, Temporal 등) 직접 호출 금지
- 필요한 경우 monkeypatch 사용
- async 대상은 async 테스트로 생성
- 최소 1개 이상의 assert 또는 pytest.raises 포함
- branch/def-use/exception 목표 라인을 반드시 타격
- JSON 이외의 출력 금지

USER:
Goal ID: 0001
file: activities.py
function: refund
target_lines: [58, 59, 62, 63]
components:
  - branch: 58
  - def-use: confirmation (59 → 62)
  - exception: InvalidAccountError at 63
입력 제약과 경로 조건을 모두 만족하도록 pytest 테스트를 생성하세요.
```

---

### 2.2 refine 프롬프트 예시 (3.6 단계)

```
SYSTEM:
당신은 기존 pytest 테스트를 보강하여 미커버 타겟 라인에 도달하도록 수정하는 전문가입니다.
출력은 단일 JSON만 허용합니다:
{
  "edits": [
    {"id": "<goal_id::filename>", "new_code": "<전체 테스트 코드 문자열>"}
  ]
}

지침:
- 구조는 유지하되 입력/경계조건/호출 순서를 조정해 still_missing_target_lines에 도달
- 외부 부작용 금지 (파일/네트워크/시간/환경/Temporal)
- 필요한 경우 monkeypatch 사용
- importlib + getattr 정책 유지
- 각 테스트는 target_lines 중 최소 1개 이상 실제 실행해야 함
- 마크다운/설명/주석 포함 금지

USER:
goal_id: 0001
target_file: activities.py
still_missing_target_lines: [58, 59, 62, 63]
original_test_code: "<원본 코드>"
테스트를 타격되도록 수정해 주세요.
```

---

## 3. 실험 결과

아래 표는 업로드한 이미지의 값 그대로 사용하였다.

### 표 1. 커버리지 결과 비교

| 평가 항목            | pytest | 본 연구 복합 목표 미적용 | 본 연구 복합 목표 적용 K=10 | 본 연구 복합 목표 적용 K=5 | 본 연구 복합 목표 적용 K=1 |
|---------------------|--------|---------------------------|------------------------------|------------------------------|------------------------------|
| 실행된 테스트 개수  | 3      | 3                         | 10                           | 7                            | 3                            |
| 라인 커버리지(%)    | 35.29% | 48.10%                    | 66.09%                       | 52.94%                       | 48.10%                       |
| 분기 커버리지(%)    | 36.36% | 61.36%                    | 76.14%                       | 63.64%                       | 61.36%                       |

### 결과 해석

기준선 pytest는 단 3개의 테스트만 실행되어 라인 35.29%, 분기 36.36%로 낮은 커버리지를 보였다. 미적용군에서도 테스트를 새로 생성하지는 않았지만 실행 과정에서 더미 객체 패치가 적용되며 기존 테스트가 정상적으로 끝까지 수행되었고, 그 결과 라인 48.10%, 분기 61.36%로 일정 수준의 향상이 나타났다. 반면 복합 목표 적용군에서는 분기 흐름, 정의–사용 체인, 예외 경로를 통합한 구조가 경로 타격 범위를 확장하여 커버리지 향상이 더욱 두드러졌다. 특히 K=10 설정은 라인 66.09%, 분기 76.14%로 가장 높은 수준의 성능을 기록했으며, K=5 또한 라인 52.94%, 분기 63.64%로 미적용군보다 우수한 결과를 보여 복합 목표 기반 접근의 효과를 확인할 수 있었다. K=1의 경우 생성된 테스트 수가 적어 미적용군과 동일한 수준에 머무르며 목표 수가 충분하지 않을 때 향상 효과가 제한됨을 알 수 있었다.


---

## 4. 결론

본 연구는 분기 흐름·정의–사용 체인·예외 경로를 통합한 복합 테스트 목표를 기반으로 LLM 테스트 생성을 수행하여 기존 방식 대비 유의미한 커버리지 향상을 확인하였다. 목표 구조는 테스트 수 대비 커버리지 효율을 높였으며, refine 단계와 실행 격리 정책을 통해 안정성 또한 확보하였다. 향후 연구에서는 다양한 규모와 도메인의 프로젝트에 대한 실험 확장, 벤치마크 기반 정량 비교, LLM 출력 안정성 강화를 통해 방법론의 일반성과 실용성을 검증할 필요가 있다.
